---
layout: post
title: History of the Impossibles - CAP and FLP 
---

My undergraduate course in distributed systems was a disappointment. I started the module (in winter 2006)
anticipating highly stimulating sessions, but was quickly let down by the materials. The textbooks were not
the best, and the lecturers were clearly not passionate about the field. Times and times again over the next
ten years I found blind spots after blind spots in my understanding. It was frustrating to encounter a
(design) problem and have to work my way backwards trying to reduce it to known principles and guidelines. As
much as this problem-solving process helps remembering the principles better, I really wish these fundamentals
were (better) taught in University.

This post will be about two principles in distributed systems underlying most of modern day designs. One is
old but so well formalized that it becomes a theorem. Another, more recent and rather informal, crystallises
wisdoms in designing distributed systems, from which followed many debates and extensions.  

## Distributed Network Models
Distributed systems are built over a network of nodes, so it is important to understand the network model,
i.e. the assumptions of the network links. 

* **Asynchronous model:** the delay when sending a message from one node to another is finite but can be
unbounded.  As a consequence, a node cannot tell if the message is lost or simply being delayed. In other
words, a node cannot use **time-out/ping** as a failure detector. This model reflects worst-case
communication, but it is not too unrealistic to be useful. 

* **Synchronous model:** delay in sending a message is bounded, and finite by extension. This reflects more
accurately what we have today: the delay bound can be accurately _approximated_ by sampling. By using this
bound, one can tell with high confidence whether the message is lost. Note that in theory it is still not
possible to have an absolute bound, in practice a sufficiently long delay can be safely treated as message
loss.   


+ Failure vs. partition. 

## FLP - Agree to Disagree
FLP: consensus: safety, liveness, fault-tolerance is impossible. 

fault-tolerance is NOT the same as actually having failure

## CAP - Separation is Bad
CAP: consistency, availability, partition-tolerance is impossible. 

Replicas vs. independent parties
parition-tolerance is NOT the same as the network has partition or not. 

## FLP vs CAP - Chalk and Cheese
Chalk and Cheese:

+ Formalization: execution traces, liveness = availability. State theorems 
+ Proof. 

+ Impact/Implication:
FLP: SL, SF, LF examples
CAP: CA, AP, CP examples

## FLP Defied
Defying FLP: probabilistic failure dectector, partially synchronous network. 

## CAP Evolved
CAP falling out of favor: 
+ Problem with the formalization
+ Not binary decision.
+ Latency to model avaialability: PACELC

## Concluding Notes
Conclusion: FLP lives, CAP can be safely retired. 
