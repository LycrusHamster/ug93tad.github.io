---
layout: post
title: Evolution of Memory Vulnerabilities 
---

Computer security has established itself as a major, active and hugely impactful field of computer science. Its engine
is driven largely by perpetual arm races between attacks and defenses, between breaking stuff and patching stuff. Helped
by disproportionate media interest and sometimes biased narratives, security comes off as a fear factor, as something to
be pessimistic about. It is true that the defense guys do not always take the spotlights, that only secure systems are
ones that do nothing and thus being useless. Nevertheless, computer security is an art, and portraying their principals
at work can be great movie material. Scorpion and Mr Robot, two popular Hollywood series with their the main
heroes being computer hackers, are raising public awareness and appreciation for security professionals.  

This post traces the evolution of memory vulnerabilities, one of the most important themes in computer security. In
fact, gun on my head, I would say it is **the** very essence of the field. Although if the same gun was on my head only
a month ago, the answer would have been different. Until last month, I was familiar with general ideas about memory
vulnerabilities, and could feign interest and awe when hearing about new vulnerabilities and exploits. Having attended
few research seminars on the subject, mostly on the defensive side, I had an impression that dealing with
vulnerabilities are mundane, ad-hoc process highly dependent of the architectural specifics. In retrospect, though,
those seminars were mainly from programming language community and thus were small, biased samples. I had been seeing
trees and didn't fully appreciate the forest.     

Memory vulnerabilities are gateways to gain control over somebody else's machines. As much as exposing holes in software
implementations, they embody creativity and humans' desire to tinker. But more importantly, they drive progress in many
aspects of computer science: from hardware, operating system, compiler, software design, to operations and management.
As far as a attack-defense arm race is concerned, defense sides appear to be at disadvantage, having to face 
challenging (undecidable) problems of software verification, predicting and accounting for human behavior (One thing I
learned from a short time working in the industry is that enterprises have come to accept security exploits as inevitable and
instead are treating them as risks and spending more resources in managing them). Seen from a research perspective,
however, memory vulnerabilities and related defense mechanisms are extremely educational tools. In the process of
understanding them, I learned great deals about hardware architecture, compilers, runtime, operating systems and other
cool software techniques.  I learned to appreciate the security processes previously perceived  as cumbersome if not
redundant. And I started to marvel at how incumbent operating systems and critical software systems manage to keep
themselves as secure as they are given their complexity.  

## Preventing corruption vs. exploitation 

## Stack overflow

## Baggy bound,  NX and canaries

## Heap overflow, string and integer vulnerabilities 

## Return to libc, ROP 

## ASLR and Control Flow Integrity

## Blind hacking and breaking CFI

## Code Pointer Integrity

## Sandboxing, SFI
